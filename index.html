<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>How LLMs Work: An Interactive Guide</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=JetBrains+Mono:wght@400;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            scroll-behavior: smooth;
        }

        .code-font {
            font-family: 'JetBrains Mono', monospace;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1; 
        }
        ::-webkit-scrollbar-thumb {
            background: #cbd5e1; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8; 
        }

        .token-chip {
            transition: all 0.2s;
        }
        .token-chip:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        /* Attention Mechanism Lines */
        svg.connections {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .step-card {
            transition: transform 0.3s ease, border-color 0.3s ease;
        }
        .step-card.active {
            border-color: #3b82f6;
            transform: scale(1.01);
        }

        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800">

    <!-- Navigation -->
    <nav class="fixed top-0 w-full bg-white/80 backdrop-blur-md border-b border-slate-200 z-50">
        <div class="max-w-6xl mx-auto px-4 h-16 flex items-center justify-between">
            <div class="flex items-center space-x-2 font-bold text-xl text-blue-600">
                <i data-lucide="brain-circuit"></i>
                <span>LLM Explainer</span>
            </div>
            <div class="hidden md:flex space-x-6 text-sm font-medium text-slate-600">
                <a href="#intro" class="hover:text-blue-600 transition">Intro</a>
                <a href="#tokenization" class="hover:text-blue-600 transition">1. Tokens</a>
                <a href="#embeddings" class="hover:text-blue-600 transition">2. Embeddings</a>
                <a href="#attention" class="hover:text-blue-600 transition">3. Attention</a>
                <a href="#prediction" class="hover:text-blue-600 transition">4. Prediction</a>
            </div>
        </div>
    </nav>

    <!-- Hero Section -->
    <header id="intro" class="pt-32 pb-20 px-4 text-center max-w-4xl mx-auto">
        <div class="inline-flex items-center px-3 py-1 rounded-full bg-blue-100 text-blue-700 text-sm font-medium mb-6">
            <i data-lucide="sparkles" class="w-4 h-4 mr-2"></i> Interactive Demo
        </div>
        <h1 class="text-5xl md:text-6xl font-extrabold tracking-tight text-slate-900 mb-6">
            Inside the <span class="text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-indigo-600">AI's Brain</span>
        </h1>
        <p class="text-xl text-slate-600 mb-10 max-w-2xl mx-auto">
            Large Language Models (LLMs) aren't magic. They are giant math machines that predict the next piece of text. Let's break open the black box.
        </p>
        <a href="#tokenization" class="inline-flex items-center justify-center px-8 py-3 text-base font-medium text-white bg-blue-600 hover:bg-blue-700 rounded-lg transition-all shadow-lg hover:shadow-xl transform hover:-translate-y-1">
            Start the Journey
            <i data-lucide="arrow-down" class="ml-2 w-5 h-5"></i>
        </a>
    </header>

    <main class="max-w-5xl mx-auto px-4 pb-32 space-y-32">

        <!-- STEP 1: TOKENIZATION -->
        <section id="tokenization" class="scroll-mt-24">
            <div class="flex items-center mb-6">
                <div class="w-10 h-10 bg-blue-100 rounded-full flex items-center justify-center text-blue-600 font-bold mr-4">1</div>
                <h2 class="text-3xl font-bold text-slate-900">It Doesn't Read Words. It Reads Tokens.</h2>
            </div>
            <div class="grid md:grid-cols-2 gap-12 items-center">
                <div class="space-y-4 text-lg text-slate-600">
                    <p>
                        To an AI, the sentence "I love coding" isn't three words. It's a sequence of numbers. 
                    </p>
                    <p>
                        First, text is chopped into chunks called <strong>Tokens</strong>. A token can be a whole word, part of a word, or even a space. Common words are usually single tokens, while complex or rare words might be split up.
                    </p>
                    <div class="bg-blue-50 border-l-4 border-blue-500 p-4 text-sm text-blue-800">
                        <strong>Try it:</strong> Type in the box to see how an LLM sees your text. Notice how spaces and partial words are handled.
                    </div>
                </div>
                
                <!-- Interactive Tokenizer -->
                <div class="bg-white rounded-2xl shadow-xl border border-slate-200 p-6">
                    <label class="block text-sm font-semibold text-slate-700 mb-2">Input Text</label>
                    <textarea id="tokenizer-input" class="w-full p-3 rounded-lg border border-slate-300 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition font-sans text-lg mb-4 resize-none" rows="3" placeholder="Type something here...">Artificial Intelligence is fascinating!</textarea>
                    
                    <label class="block text-sm font-semibold text-slate-700 mb-2">Token View (Simulated)</label>
                    <div id="token-output" class="flex flex-wrap gap-2 min-h-[60px] p-4 bg-slate-50 rounded-lg border border-slate-200 code-font text-sm">
                        <!-- Tokens injected here -->
                    </div>
                    <div class="mt-4 flex justify-between text-xs text-slate-500">
                        <span id="token-count">Token count: 0</span>
                        <span>*Colors represent distinct tokens</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- STEP 2: EMBEDDINGS -->
        <section id="embeddings" class="scroll-mt-24">
            <div class="flex items-center mb-6">
                <div class="w-10 h-10 bg-indigo-100 rounded-full flex items-center justify-center text-indigo-600 font-bold mr-4">2</div>
                <h2 class="text-3xl font-bold text-slate-900">Words into Numbers (Embeddings)</h2>
            </div>
            <div class="grid md:grid-cols-2 gap-12 items-center">
                <!-- Interactive Embedding Map -->
                <div class="order-2 md:order-1 bg-slate-900 rounded-2xl shadow-xl overflow-hidden relative h-[400px] group cursor-crosshair">
                    <div class="absolute top-4 left-4 z-10 bg-black/50 backdrop-blur px-3 py-1 rounded text-white text-xs">
                        2D Visualization of Vector Space
                    </div>
                    <canvas id="embedding-canvas" class="w-full h-full block"></canvas>
                    <div id="embedding-tooltip" class="absolute pointer-events-none bg-white px-3 py-2 rounded shadow-lg text-sm font-bold opacity-0 transition-opacity z-20" style="top:0; left:0;"></div>
                </div>

                <div class="order-1 md:order-2 space-y-4 text-lg text-slate-600">
                    <p>
                        Once tokenized, each token is converted into a list of numbers called a <strong>Vector</strong>.
                    </p>
                    <p>
                        Imagine a giant map. Words with similar meanings (like "King" and "Queen", or "Apple" and "Pear") live close to each other on this map.
                    </p>
                    <p>
                        This allows the AI to understand relationships. It knows that "Paris" is to "France" what "Tokyo" is to "Japan" just by looking at the distance and direction between them.
                    </p>
                    <div class="bg-indigo-50 border-l-4 border-indigo-500 p-4 text-sm text-indigo-800">
                        <strong>Interactive Map:</strong> Hover over the dots to see words clustered by meaning (Technology, Food, Animals, Royalty).
                    </div>
                </div>
            </div>
        </section>

        <!-- STEP 3: ATTENTION -->
        <section id="attention" class="scroll-mt-24">
            <div class="flex items-center mb-6">
                <div class="w-10 h-10 bg-purple-100 rounded-full flex items-center justify-center text-purple-600 font-bold mr-4">3</div>
                <h2 class="text-3xl font-bold text-slate-900">The Attention Mechanism</h2>
            </div>
            <div class="space-y-6">
                <p class="text-lg text-slate-600 max-w-3xl">
                    This is the secret sauce. When an LLM processes a word, it "looks back" at all previous words to figure out the context. It assigns an <strong>Attention Score</strong> to determine how important other words are to the current word.
                </p>

                <div class="bg-white rounded-2xl shadow-xl border border-slate-200 p-8 relative overflow-hidden">
                    <div class="text-center mb-8">
                        <h3 class="font-bold text-slate-700">Hover over a word to see what the AI "pays attention" to:</h3>
                    </div>

                    <!-- Sentence Container -->
                    <div class="relative flex justify-center flex-wrap gap-x-3 gap-y-8 text-xl md:text-2xl font-serif max-w-2xl mx-auto py-12" id="attention-sentence">
                        <!-- Words injected by JS -->
                    </div>

                    <div class="absolute bottom-4 left-0 w-full text-center text-sm text-slate-400">
                        Thickness of line = Strength of attention
                    </div>
                </div>
                
                <p class="text-sm text-slate-500 italic">
                    Example: In "The animal didn't cross the street because <strong>it</strong> was too tired", when the AI reads "it", it pays huge attention to "animal" to know what "it" refers to.
                </p>
            </div>
        </section>

        <!-- STEP 4: PREDICTION & TEMPERATURE -->
        <section id="prediction" class="scroll-mt-24">
            <div class="flex items-center mb-6">
                <div class="w-10 h-10 bg-emerald-100 rounded-full flex items-center justify-center text-emerald-600 font-bold mr-4">4</div>
                <h2 class="text-3xl font-bold text-slate-900">Predicting the Future</h2>
            </div>
            
            <div class="grid lg:grid-cols-3 gap-8">
                <!-- Left: Explanation -->
                <div class="lg:col-span-1 space-y-4 text-lg text-slate-600">
                    <p>
                        The LLM doesn't just pick one word. It calculates the probability for <em>every possible word</em> in its vocabulary appearing next.
                    </p>
                    <p>
                        <strong>Temperature</strong> controls how "risky" the AI is. 
                    </p>
                    <ul class="list-disc pl-5 text-sm space-y-2">
                        <li><strong>Low Temp (0.1):</strong> Boring, accurate. Always picks the most likely word.</li>
                        <li><strong>High Temp (1.0+):</strong> Creative, chaotic. Might pick less likely words.</li>
                    </ul>
                </div>

                <!-- Right: Interactive Demo -->
                <div class="lg:col-span-2 bg-slate-900 text-white rounded-2xl shadow-2xl p-6 md:p-8 flex flex-col">
                    
                    <!-- Context Display -->
                    <div class="mb-6 font-mono text-lg">
                        <span class="text-slate-400">INPUT:</span><br>
                        "The quick brown fox jumps over the <span id="target-blank" class="border-b-2 border-emerald-500 text-emerald-400 animate-pulse">...</span>"
                    </div>

                    <!-- Controls -->
                    <div class="mb-8 p-4 bg-white/5 rounded-lg border border-white/10">
                        <div class="flex justify-between items-center mb-2">
                            <label class="text-xs font-bold uppercase tracking-wider text-slate-400">Temperature: <span id="temp-val" class="text-white">0.5</span></label>
                            <span id="temp-desc" class="text-xs px-2 py-1 rounded bg-blue-500/20 text-blue-300">Balanced</span>
                        </div>
                        <input type="range" id="temp-slider" min="0.1" max="1.5" step="0.1" value="0.5" class="w-full range-slider h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer">
                        <div class="flex justify-between text-[10px] text-slate-500 mt-1">
                            <span>Strict (0.1)</span>
                            <span>Creative (1.5)</span>
                        </div>
                    </div>

                    <!-- Visualization of Probabilities -->
                    <div class="flex-1">
                        <div class="flex justify-between items-end mb-2">
                            <span class="text-sm font-bold text-slate-300">Top Probabilities</span>
                            <button id="generate-btn" class="bg-emerald-600 hover:bg-emerald-500 text-white px-4 py-2 rounded-lg text-sm font-bold transition flex items-center">
                                <i data-lucide="play" class="w-4 h-4 mr-1"></i> Generate Next
                            </button>
                        </div>
                        
                        <div id="prob-bars" class="space-y-3 font-mono text-sm">
                            <!-- Bars injected via JS -->
                        </div>
                        
                        <div id="result-display" class="mt-6 pt-4 border-t border-white/10 text-center hidden">
                            <div class="text-slate-400 text-xs uppercase mb-1">Selected Token</div>
                            <div class="text-3xl font-bold text-emerald-400 fade-in" id="chosen-word"></div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Conclusion -->
        <section class="text-center py-12 bg-white rounded-3xl shadow-sm border border-slate-200">
            <h2 class="text-2xl font-bold text-slate-900 mb-4">Summary</h2>
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 px-4 max-w-4xl mx-auto">
                <div class="p-4 bg-slate-50 rounded-xl">
                    <i data-lucide="scissors" class="w-8 h-8 text-blue-500 mx-auto mb-2"></i>
                    <h3 class="font-bold text-sm">1. Tokenize</h3>
                    <p class="text-xs text-slate-500">Chop text into numbers</p>
                </div>
                <div class="p-4 bg-slate-50 rounded-xl">
                    <i data-lucide="network" class="w-8 h-8 text-indigo-500 mx-auto mb-2"></i>
                    <h3 class="font-bold text-sm">2. Embed</h3>
                    <p class="text-xs text-slate-500">Map meaning in space</p>
                </div>
                <div class="p-4 bg-slate-50 rounded-xl">
                    <i data-lucide="search" class="w-8 h-8 text-purple-500 mx-auto mb-2"></i>
                    <h3 class="font-bold text-sm">3. Attend</h3>
                    <p class="text-xs text-slate-500">Find context links</p>
                </div>
                <div class="p-4 bg-slate-50 rounded-xl">
                    <i data-lucide="dices" class="w-8 h-8 text-emerald-500 mx-auto mb-2"></i>
                    <h3 class="font-bold text-sm">4. Predict</h3>
                    <p class="text-xs text-slate-500">Roll dice for next word</p>
                </div>
            </div>
        </section>

    </main>

    <footer class="bg-slate-900 text-slate-400 py-8 text-center text-sm">
        <p>&copy; 2024 LLM Explainer. Built for educational purposes.</p>
    </footer>

    <script>
        // Initialize Lucide Icons
        lucide.createIcons();

        // --- 1. TOKENIZER LOGIC (SIMULATED) ---
        const tokenInput = document.getElementById('tokenizer-input');
        const tokenOutput = document.getElementById('token-output');
        const tokenCount = document.getElementById('token-count');

        const colors = [
            'bg-blue-100 text-blue-800 border-blue-200',
            'bg-green-100 text-green-800 border-green-200',
            'bg-purple-100 text-purple-800 border-purple-200',
            'bg-orange-100 text-orange-800 border-orange-200',
            'bg-pink-100 text-pink-800 border-pink-200',
            'bg-cyan-100 text-cyan-800 border-cyan-200'
        ];

        function simulateTokenization(text) {
            // A crude simulation of BPE/WordPiece tokenization
            // Logic: Split by spaces, but also split common suffixes or punctuation
            let rawTokens = text.match(/[\w']+|[.,!?;]|\s+/g) || [];
            
            // Further simulate sub-word splitting for longer words (fake but educational)
            let refinedTokens = [];
            rawTokens.forEach(t => {
                if (t.length > 5 && /^[a-zA-Z]+$/.test(t)) {
                    // Split long words arbitrarily to show sub-tokens
                    let mid = Math.floor(t.length / 2);
                    refinedTokens.push(t.slice(0, mid));
                    refinedTokens.push(t.slice(mid));
                } else {
                    refinedTokens.push(t);
                }
            });

            return refinedTokens;
        }

        function renderTokens() {
            const text = tokenInput.value;
            const tokens = simulateTokenization(text);
            tokenOutput.innerHTML = '';
            
            tokens.forEach((token, index) => {
                const chip = document.createElement('span');
                const colorClass = colors[index % colors.length];
                // Replace spaces with a visible symbol for clarity
                const displayToken = token.replace(/\s/g, '&nbsp;'); 
                
                chip.className = `token-chip inline-block px-2 py-1 m-1 rounded border ${colorClass} font-mono cursor-default select-none`;
                chip.innerHTML = displayToken;
                chip.title = `ID: ${Math.floor(Math.random() * 50000)}`; // Fake ID
                tokenOutput.appendChild(chip);
            });

            tokenCount.textContent = `Token count: ${tokens.length}`;
        }

        tokenInput.addEventListener('input', renderTokens);
        renderTokens(); // Initial run

        // --- 2. EMBEDDINGS CANVAS ---
        const canvas = document.getElementById('embedding-canvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('embedding-tooltip');
        let width, height;

        // Data: Clusters of words
        const clusters = [
            { name: "Royalty", color: "#6366f1", words: ["King", "Queen", "Prince", "Princess", "Castle", "Throne", "Crown", "Monarch"] },
            { name: "Technology", color: "#3b82f6", words: ["Computer", "AI", "Robot", "Code", "Internet", "Screen", "Data", "Chip"] },
            { name: "Food", color: "#10b981", words: ["Apple", "Pizza", "Burger", "Banana", "Bread", "Cook", "Taste", "Chef"] },
            { name: "Animals", color: "#f59e0b", words: ["Dog", "Cat", "Lion", "Tiger", "Bird", "Fish", "Wolf", "Bear"] }
        ];

        let points = [];

        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            width = canvas.width;
            height = canvas.height;
            initPoints();
            draw();
        }

        function initPoints() {
            points = [];
            clusters.forEach((cluster, i) => {
                // Distribute clusters in quadrants
                const cx = (i % 2 === 0) ? width * 0.3 : width * 0.7;
                const cy = (i < 2) ? height * 0.3 : height * 0.7;

                cluster.words.forEach(word => {
                    points.push({
                        x: cx + (Math.random() - 0.5) * width * 0.25,
                        y: cy + (Math.random() - 0.5) * height * 0.25,
                        word: word,
                        color: cluster.color,
                        category: cluster.name,
                        radius: 5
                    });
                });
            });
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);
            
            // Draw connections between points in same cluster (faint)
            ctx.globalAlpha = 0.2;
            clusters.forEach(cluster => {
                ctx.strokeStyle = cluster.color;
                ctx.beginPath();
                const clusterPoints = points.filter(p => p.category === cluster.name);
                for(let i=0; i<clusterPoints.length; i++) {
                    for(let j=i+1; j<clusterPoints.length; j++) {
                        if(Math.random() > 0.8) { // Only some lines
                            ctx.moveTo(clusterPoints[i].x, clusterPoints[i].y);
                            ctx.lineTo(clusterPoints[j].x, clusterPoints[j].y);
                        }
                    }
                }
                ctx.stroke();
            });
            ctx.globalAlpha = 1.0;

            // Draw points
            points.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.fill();
                // Text label (faint unless hovered - simulated logic)
                ctx.fillStyle = "rgba(255,255,255,0.7)";
                ctx.font = "10px Inter";
                ctx.fillText(p.word, p.x + 8, p.y + 3);
            });
        }

        // Mouse Interaction for Canvas
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            let hovered = false;

            points.forEach(p => {
                const dist = Math.sqrt((mouseX - p.x)**2 + (mouseY - p.y)**2);
                if (dist < 15) {
                    tooltip.style.opacity = 1;
                    tooltip.style.transform = `translate(${e.clientX + 10}px, ${e.clientY + 10}px)`; // Fixed relative to viewport via CSS
                    // Fix: calculate relative to container for cleanliness, but simplified here
                    tooltip.style.left = (mouseX + 10) + 'px';
                    tooltip.style.top = (mouseY + 10) + 'px';
                    tooltip.innerHTML = `<span style="color:${p.color}">‚óè</span> ${p.word}<br><span class="text-xs text-slate-400">${p.category}</span>`;
                    p.radius = 8;
                    hovered = true;
                } else {
                    p.radius = 5;
                }
            });

            if (!hovered) {
                tooltip.style.opacity = 0;
            }
            draw();
        });

        window.addEventListener('resize', resizeCanvas);
        setTimeout(resizeCanvas, 100); // Delay for layout to settle

        // --- 3. ATTENTION MECHANISM ---
        const attentionSentence = [
            { text: "The", focus: [] },
            { text: "animal", focus: [] },
            { text: "didn't", focus: ["animal"] },
            { text: "cross", focus: ["animal", "didn't"] },
            { text: "the", focus: ["cross"] },
            { text: "street", focus: ["cross", "the"] },
            { text: "because", focus: ["cross", "didn't"] },
            { text: "it", focus: ["animal", "street"] }, // Key ambiguity resolution
            { text: "was", focus: ["it"] },
            { text: "too", focus: ["was"] },
            { text: "tired", focus: ["animal", "it"] },
            { text: "." , focus: []}
        ];

        const attContainer = document.getElementById('attention-sentence');
        let wordElements = [];

        function renderAttention() {
            attContainer.innerHTML = '';
            wordElements = [];

            // Create SVG Layer
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.classList.add('connections');
            attContainer.appendChild(svg);

            attentionSentence.forEach((item, index) => {
                const span = document.createElement('span');
                span.textContent = item.text;
                span.className = "relative z-20 cursor-pointer px-1 rounded transition hover:bg-blue-100 hover:text-blue-700";
                span.dataset.index = index;
                
                span.addEventListener('mouseenter', () => highlightAttention(index, svg));
                span.addEventListener('mouseleave', () => clearAttention(svg));
                
                attContainer.appendChild(span);
                wordElements.push(span);
            });
        }

        function highlightAttention(currentIndex, svg) {
            // Clear old lines
            while(svg.firstChild) svg.removeChild(svg.firstChild);

            const currentData = attentionSentence[currentIndex];
            const currentEl = wordElements[currentIndex];
            const currentRect = currentEl.getBoundingClientRect();
            const containerRect = attContainer.getBoundingClientRect();

            // Highlight target words
            currentData.focus.forEach(targetText => {
                // Find previous occurrences of this word
                const targetIndex = attentionSentence.findIndex((w, i) => w.text === targetText && i < currentIndex);
                
                if (targetIndex !== -1) {
                    const targetEl = wordElements[targetIndex];
                    const targetRect = targetEl.getBoundingClientRect();

                    // Calculate relative coordinates
                    const x1 = currentRect.left + (currentRect.width / 2) - containerRect.left;
                    const y1 = currentRect.top + (currentRect.height / 2) - containerRect.top;
                    const x2 = targetRect.left + (targetRect.width / 2) - containerRect.left;
                    const y2 = targetRect.top + (targetRect.height / 2) - containerRect.top;

                    // Draw Bezier Curve
                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    const midY = Math.min(y1, y2) - 40; // Arc height
                    
                    const d = `M ${x1} ${y1} Q ${(x1+x2)/2} ${midY} ${x2} ${y2}`;
                    
                    path.setAttribute("d", d);
                    path.setAttribute("fill", "none");
                    path.setAttribute("stroke", "#3b82f6"); // Blue line
                    path.setAttribute("stroke-width", "2");
                    path.setAttribute("stroke-opacity", "0.6");
                    
                    svg.appendChild(path);

                    targetEl.classList.add("bg-yellow-100", "text-yellow-800", "font-bold");
                }
            });
        }

        function clearAttention(svg) {
            while(svg.firstChild) svg.removeChild(svg.firstChild);
            wordElements.forEach(el => {
                el.classList.remove("bg-yellow-100", "text-yellow-800", "font-bold");
            });
        }

        renderAttention();

        // --- 4. PREDICTION & TEMPERATURE ---
        const slider = document.getElementById('temp-slider');
        const tempVal = document.getElementById('temp-val');
        const tempDesc = document.getElementById('temp-desc');
        const generateBtn = document.getElementById('generate-btn');
        const probBars = document.getElementById('prob-bars');
        const resultDisplay = document.getElementById('result-display');
        const chosenWordEl = document.getElementById('chosen-word');

        // Base probabilities for "The quick brown fox jumps over the ..."
        const baseProbs = [
            { word: "lazy", prob: 0.8 },
            { word: "fence", prob: 0.1 },
            { word: "log", prob: 0.05 },
            { word: "moon", prob: 0.03 },
            { word: "spaghetti", prob: 0.001 } // Very unlikely
        ];

        // Softmax simulation with temperature
        function calculateSoftmax(items, temp) {
            // Apply temperature: z_i / T
            // Note: We'll fake the "logits" by taking log of prob first, then applying temp, then softmax
            // Or simpler: p_new = p_old ^ (1/T) / sum(...)
            
            let newProbs = items.map(item => ({
                word: item.word,
                score: Math.pow(item.prob, 1 / temp)
            }));

            const sum = newProbs.reduce((a, b) => a + b.score, 0);
            return newProbs.map(item => ({
                word: item.word,
                prob: item.score / sum
            })).sort((a, b) => b.prob - a.prob);
        }

        function updateViz() {
            const temp = parseFloat(slider.value);
            tempVal.textContent = temp.toFixed(1);
            
            // Update Description
            if(temp < 0.4) { tempDesc.textContent = "Deterministic"; tempDesc.className = "text-xs px-2 py-1 rounded bg-blue-500/20 text-blue-300"; }
            else if(temp < 0.9) { tempDesc.textContent = "Balanced"; tempDesc.className = "text-xs px-2 py-1 rounded bg-green-500/20 text-green-300"; }
            else { tempDesc.textContent = "Chaotic"; tempDesc.className = "text-xs px-2 py-1 rounded bg-red-500/20 text-red-300"; }

            // Recalculate Probs
            const currentProbs = calculateSoftmax(baseProbs, temp);

            // Render Bars
            probBars.innerHTML = '';
            currentProbs.forEach(p => {
                const percentage = (p.prob * 100).toFixed(1);
                const barWidth = Math.max(percentage, 1); // min width for visibility
                
                const row = document.createElement('div');
                row.className = "flex items-center gap-2";
                row.innerHTML = `
                    <div class="w-20 text-right text-slate-400 truncate">${p.word}</div>
                    <div class="flex-1 h-6 bg-slate-800 rounded overflow-hidden relative group cursor-help" title="${percentage}%">
                        <div class="h-full bg-emerald-500/80 transition-all duration-300" style="width: ${barWidth}%"></div>
                        <span class="absolute inset-0 flex items-center pl-2 text-xs text-white/90 drop-shadow-md">${percentage}%</span>
                    </div>
                `;
                probBars.appendChild(row);
            });

            return currentProbs;
        }

        function pickWord(probs) {
            const r = Math.random();
            let cumulative = 0;
            for(let item of probs) {
                cumulative += item.prob;
                if(r <= cumulative) return item.word;
            }
            return probs[probs.length - 1].word;
        }

        slider.addEventListener('input', updateViz);

        generateBtn.addEventListener('click', () => {
            const probs = updateViz();
            const word = pickWord(probs);
            
            resultDisplay.classList.remove('hidden');
            chosenWordEl.textContent = word;
            chosenWordEl.parentElement.classList.remove('fade-in');
            void chosenWordEl.parentElement.offsetWidth; // trigger reflow
            chosenWordEl.parentElement.classList.add('fade-in');

            // Also update the sentence above
            const blank = document.getElementById('target-blank');
            blank.textContent = word;
            blank.classList.remove('animate-pulse');
        });

        // Initial setup
        updateViz();

    </script>
</body>
</html>